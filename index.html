<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="P2P Computing : A reliable P2P structured compute engine" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>P2P Computing</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/290B/p2p">View on GitHub</a>

          <h1 id="project_title">P2P Computing</h1>
          <h2 id="project_tagline">A reliable P2P structured compute engine</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/290B/p2p/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/290B/p2p/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p><strong>Oeyvind Rein and Torgeir Lien</strong></p>

<p>UCSB CMPSC 290B, Fall 2012</p>

<h2>Abstract</h2>

<p>We have implemented a P2P compute engine that does not fail if one or multiple peers crashes or disconnects. The system supports Divide And Conquer (DAC), shared variables, is scalable and does not suffer from bottlenecks due to network communication. </p>

<h2>Introduction</h2>

<p>A space-worker compute system has one or many centralized spaces. A lot of tasks and data are being sent to, from and through these spaces which makes the system vulnerable if one should fail. There are ways to handle a failed space but the process can be complicated. One approach is to let a worker step in as a space and receive a backup state from another space. This may not always be good solution because workers can have different hardware than spaces and might not be that centralized in the physical network. </p>

<p>In a P2P compute system the communication between the peers is equal, which means no bottlenecks. Since all computers are treated the same and behaves the same the result of a failing peer will only result in reduced computational power of one computer. Because of the simple topology of P2P networks this compute system will be very easy to set up and can be scalable. </p>

<h2>Functional Requirements</h2>

<ul>
<li><p>The network starts with a single peer which starts its own network. Other peers can connect to the network by sending a connect message to any peer in the network given by IP and port. There is no notion of a tracker or a centralized system for handling connects and failures.</p></li>
<li><p>The failure of a peer will be detected when a communication attempt fails and a RMI exception is caught.</p></li>
<li><p>It is possible to share objects between the peers in the system in order to solve more complex problems.</p></li>
<li><p>Workload will be distributed evenly between peers and their workers by keeping a short work queue and making peers request more work from random peers in the network. Test by spawning large TSP task, make sure that all peers have enough work at all times. The goal is to make this system utilize processing power better than the system that was made in homework 5.</p></li>
<li><p>The system is fail-safe. Any number of peers can crash without breaking the network or the current computation. The system doesn't tolerate that two peers crash at the same time. Test by running a large task and then force some peers to disconnect while computing tasks.</p></li>
<li><p>This project is realized as an API which people can use to distribute their computations on a distributed cluster.</p></li>
</ul><h2>Performance Requirements</h2>

<p>The performance of the system will be tested by running three kinds of tasks; TSP, Mandelbrot and Fibonacci computations. The goal is that the peer to peer system should compute these tasks faster than what has been achieved in the homework tasks in the course. The performance of the homework compute system is well documented and should be easily comparable to the measurement from the peer to peer system. </p>

<p>When we push the number of machines and cores in the network we expect to see better results than from the homework since the space became a bottle neck in the system. The peer to peer network has no such bottle neck and should be able to handle the massive amount of message passing better.</p>

<h2>Key Technical Issues</h2>

<ul>
<li><p>Making the system consistent when faced with failing machines and randomly disconnecting peers</p></li>
<li><p>Distributing workload as efficiently as possible</p></li>
<li><p>Sharing variables between the peers</p></li>
<li><p>Keeping Divide and Conquer and other functionality from earlier work (homework 5 in 290B)</p></li>
</ul><h2>Architecture</h2>

<p>TODO javadoc link
See Javadocs for code specific architecture. </p>

<ul>
<li><p>The peer to peer system has no central authority, all peers are equal.</p></li>
<li><p>All peers can talk to all other peers whenever they want to. It is possible to send messages to specific peers or simply a broadcast to all peers. All peers keeps references to all the other peers in the network.</p></li>
<li><p>Workload distribution is implemented as random work stealing. That is, whenever the task queue of a peer is shorter than some limit, the peer will start asking random peers for more work.</p></li>
<li><p>The task system supports DAC and the ability to share a variable between the workers.</p></li>
<li><p>The shared variable will be broadcasted to all peers which will update their variable if it is "newer" than the one they already have.</p></li>
<li><p>Failure tolerance is achieved by storing copies of the task queues as a remote queue in another peer so that the data isn't lost in case the peer fails. Each time a peer connects or loses it's remote queue it will ask if some peer in the network can keep a copy of it's tasks. Each peer can store as many as two queues for other peers. When a peer detects that the peer it is holding a copy queue for has failed it will merge the copy-queue into it's own task queue.</p></li>
</ul><h2>Experiments</h2>

<p>When the results are compared with those from homework 5 it seems that the system is faster at some tasks but slower at others. Typically, tasks with a lot of message passing has become faster, while tasks which needs to send a lot of data becomes slower since the P2P implementation moves data around a bit more than the homework system. One reason for the reduced execution time of some tasks may be that a different data structure is used for holding the task queues in the P2P implementation vs. the homework implementation. This data could possibly have been implemented in the homework as well and given it a significant speed up.</p>

<p>Below a figure of the measured execution times can bee seen. The execution times measured is the average of ten samples.</p>

<p><img src="http://www.cs.ucsb.edu/%7Etorgel/290b/p2p/experimental-data.png" alt="Execution times for various tasks"></p>

<h2>Conclusions [and Future Work]</h2>

<p>The system that has been created is failure tolerant, and as long as only one machine fails at a time, every peer can fail in succession until only one is left. The system is also somewhat faster than the homework, especially at tasks, like Fibonacci, which sends a huge amount of messages. It must be mentioned that the speed up may be a result of choosing a more efficient data structure in the P2P system than in the homework system.</p>

<p>The system's API should be relatively easy to use for someone who wants to distribute work on a cluster.</p>

<h2>References</h2>

<p><a href="https://docs.google.com/presentation/d/16m83JV8LcCqfi9ZARdg1_cN7ZgimBz6GvWBRLZE8oLM/edit">Project presentation slides</a></p>

<p>Jim Waldo, Geoff Wyant, Ann Wollrath, and Sam Kendall. A Note on Distributed Computing. SMLI TR-94-29, Sun Microsystems Laboratories, M/S 29-01, 2550 Garcia Avenue Mountain View, CA 94043, November 1994. </p>

<p>Robert D. Blumofe, Christopher F. Joerg, Bradley C. Kuszmaul, Charles E. Leiserson, Keith H. Randall, and Yuli Zhou. Cilk: An Efficient Multithreaded Runtime System,ACM SIGPLAN Symposium on Principles &amp; Practice of Parallel Programming (PPoPP '95), Santa Barbara CA, July 19 - 21, 1995. </p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">P2P Computing maintained by <a href="https://github.com/290B">290B</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
